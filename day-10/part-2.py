# arrangement - the arrangement of adapters
# initial_index - the first index to evaluate (avoids looking at already evaluated adapters)
# level - how 
def evaluate_arrangement(arrangement,initial_index,level):
	global evaluations
	evaluations += 1
	level_prefix = (level - 1) * '\t'
	print('%sinitial_index %s, level %s' %(level_prefix,initial_index,level))
	# assume passed in arrangement is valid
	valid_arrangements = 1
	
	i = initial_index
	while i < len(arrangement)-2:
		print('%si: %s, this element: %s' %(level_prefix,i,arrangement[i]))
		furthest_index = i+1
		start_index = i-1
		print('intial furthest_index',furthest_index,'start_index',start_index)
		# a gap of 3 in a sequence of 3 (one must be a jump of 2)
		if(arrangement[furthest_index] - arrangement[start_index] == 3):
			return 2 * evaluate_arrangement(arrangement,i + 1,level+1)
		# a sequence of 3 in a row
		elif(arrangement[furthest_index] - arrangement[start_index] == 2):
			# let's see how far we can go
			furthest_index = i+1
			# while the gap between numbers equals the gap in the index (i.e. the adapters keep incrementing by 1)
			while(arrangement[furthest_index] - arrangement[start_index] == furthest_index - start_index):
				furthest_index += 1
			# the while loop takes the furthest_index one too far
			furthest_index -= 1

			# if this was a string of just 3
			if furthest_index - start_index == 2:
				# with strings of 3, we can remove the middle adapter and that's it
				# so there are two possibilities, which means that all future adapter combinations should be doubled
				return 2 * evaluate_arrangement(arrangement,i + 1,level+1)
			# this was a string of 4+
			else:
				# with strings of 4+ there are variable possibilities. the gap array takes care of that.
				return gap_array[furthest_index-start_index] * evaluate_arrangement(arrangement,i + furthest_index-start_index,level+1)
		else:
			i += 1
	return valid_arrangements

# placing the rows from the input file into a list
with open('input-1') as input_file:
	input_lines = input_file.readlines()

# first adapter is always 0
adapters = [0]
for input_line in input_lines:
	adapters.append(int(input_line.rstrip()))
# sorts the adapters from low to high
adapters.sort()
# last adapter is always the penultimate adapter + 3
adapters.append(adapters[len(adapters) - 1] + 3)

# this is how many valid combinations are generated by various streams of consecutive adapters
# i generated this using a more brute force approach that won't solve the general case
# this length array is apparently enough to cover anything that appears in the puzzle data
gap_array = [None, None, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504]

evaluations = 0
print(adapters)
print evaluate_arrangement(adapters,1,1)
print 'Solved in %s evaluations' %(evaluations)